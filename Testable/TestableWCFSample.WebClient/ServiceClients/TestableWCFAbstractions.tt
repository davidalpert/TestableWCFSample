<#@template debug="true" hostSpecific="true" language="C#v3.5" #>
<#@output extension=".cs" #>
<#@include file="../T4/MultipleFilesManager.ttinclude" #>
<# 
// 0. Customize the include directive above to reference Damien Guard's 
//    multiple file generator helper template: http://bit.ly/el3KaA

// 1. Customize the namespace of the ServiceClient classes:
var serviceClientNamespace = "";

// 2. Customize the namespace for the testable wrappers:
var wrapperNamespace = "";

// 3. Add the names of each service that you want 
//    to wrap into the following list:
var serviceClientNames = new List<string>() {
	"CatalogService"
};

// 4. Customize the generated file format:
bool includeComments = false;
bool generateIndividualFiles = false;
bool generateLogOutput = generateIndividualFiles;

// 4. Run the transformation to generate your wrappers!
//    a) Make sure the "Custom Tool" property of this .tt 
//       file is set to "TextTemplatingFileGenerator"
//    b) Make a change to this file .tt file, then save it to 
//       run the transformation automatically.
//    c) Right-click on this .tt file in the Solution Explorer
//       and select "Run Custom Tool" to run the transformation
//       on-demand.

// ------------------------------------------------------------------------- 

	// Create an instance of Damien Guard's multiple file manager helper class:
	var manager = Manager.Create(Host, GenerationEnvironment);
	
	// Are we wrapping the abstractions in a namespace?
	bool requireNamespace = String.IsNullOrEmpty(wrapperNamespace) == false;
	
	// Are the ServiceClient classes in a namespace?
	bool requireUsing = String.IsNullOrEmpty(serviceClientNamespace) == false 
	                 && serviceClientNamespace != wrapperNamespace;
	                 
	bool ServiceModelUsingIsRendered = false;
	                 
	// At the start of every generated file we need to write 
	// the using and namespace declaration, if needed:
	manager.StartHeader(); #>
// DO NOT MODIFY BY HAND; code generated by a template.

<#	if (requireNamespace) { #> 
<#= "namespace  "+wrapperNamespace+" {" #>
<#	}

	if (requireUsing) { #>
	<#= "using "+serviceClientNamespace+";" #>
<#	}

	manager.EndBlock(); 
	
	// And at the end of every generated file we need to close
	// the namespace, if it was opened:
	manager.StartFooter();
	
	if (requireNamespace) { #> 
}

<#	}

	manager.EndBlock(); 

	foreach (string serviceName in serviceClientNames) {

	// generate the names of the ServiceClient components:
	var serviceInterface = "I"+serviceName;
	var serviceClient = serviceName+"Client";

	// generate the names of the wrapper components:
	var clientInterface = "I"+serviceClient;
	var clientProxy = serviceClient+"Proxy";
	var clientFactory = serviceClient+"Factory";
	var clientFactoryInterface = clientInterface+"Factory";

	if (generateLogOutput) { #>
// Generating WCFAbstractions for <#= serviceClient #> : <#= serviceInterface #>
// - <#= clientInterface #>
<# }

	// Component #1 ----------------------------------------------------------
	manager.StartNewFile(clientInterface+".generated.cs"); 
	
	if (ServiceModelUsingIsRendered == false) { #>
	using System.ServiceModel;

<#		ServiceModelUsingIsRendered = true;
	}
	
	if (includeComments) { #>
/// <summary>
/// Wraps the <see cref="<#= serviceInterface#>"/> interface and 
/// the <see cref="ICommunicationObject"/> interface 
/// (implemented by <see cref="<#= serviceClient #>"/> : 
/// <see cref="ClientBase<<#= serviceInterface#>>"/>)
/// </summary>
/// <remarks>
/// <para>
/// Consumers of this interface can take responsibility for closing the 
/// communciations channel through ICommunicationObject's Close() method.
/// </para><para>
/// Based on the technique described here: 
/// http://stackoverflow.com/questions/2509316/best-way-to-mock-wcf-client-proxy
/// </para>
/// </remarks>
<#	} #>
public interface <#= clientInterface #> : <#= serviceInterface #>, ICommunicationObject
{
}

<# manager.EndBlock(); 
   if (generateLogOutput) { #>
// - <#= clientProxy #>
<#	}
	
	// Component #2 ----------------------------------------------------------
	manager.StartNewFile(clientProxy+".generated.cs"); 
	
	if (includeComments) { #>
/// <summary>
/// This class extends <see cref="<#= serviceClient #>"/> 
/// (which already implements <see cref="<#= serviceInterface #>"/>)
/// with an explicit hook to <see cref="ICommunicationsObject"/>
/// by way of the linking interface <see cref="<#= clientInterface #>"/>.
/// </summary>
/// <remarks>
/// The linking of the svcutil-generated <see cref="<#= serviceInterface #>"/> 
/// with the framework-based <see cref="ICommunicationsObject"/> means 
/// that you can now use an <see cref="<#= clientInterface #>"/> in place
/// of <see cref="<#= serviceInterface #>"/>; it has all the methods of the 
/// source WCF service endpoint but also has available the methods
/// and properties needed to properly manage a WCF service client via
/// an interface.
/// </remarks>
<#	} #>
public class <#= clientProxy #> : <#= serviceClient #>, <#= clientInterface #>
{
}

<#	manager.EndBlock(); 

	if (generateLogOutput) { #>
// - <#= clientFactoryInterface #>
<#	}

	// Component #3 ----------------------------------------------------------
	manager.StartNewFile(clientFactoryInterface+".generated.cs"); 
   
	if (includeComments) { #>
/// <summary>
/// Abstracts the <see cref="<#= clientFactoryInterface #>"/> so 
/// that it can easily be mocked to inject a fake 
/// <see cref="<#= clientInterface #>"/> into a class that wants
/// to take responsibility for both creating and closing a
/// WCF <see cref="<#= clientInterface #>"/> connection.
/// </summary>
/// <remarks>
/// Based on the technique described here: 
/// http://stackoverflow.com/questions/2509316/best-way-to-mock-wcf-client-proxy
/// </remarks>
<# } #>
public interface <#= clientFactoryInterface #>
{
    <#= clientInterface #> Build<#= serviceClient #>();
}

<#	manager.EndBlock(); 

	if (generateLogOutput) { #>
// - <#= clientFactory #>
<#	} 

	// Component #4 ----------------------------------------------------------
	manager.StartNewFile(clientFactory+".generated.cs"); 
	
	if (includeComments) { #>
/// <summary>
/// Responsible for building or creating an 
/// <see cref="<#= clientInterface #>"/> instance.
/// </summary>
/// <remarks>
/// <para>
/// This is the default run-time implementation of an 
/// <see cref="<#= clientFactoryInterface #>"/> that builds a
/// <see cref="<#= clientProxy #>"/>, extending the desired
/// <see cref="<#= serviceClient #>"/> to explicitly expose the
/// <see cref="ICommunicationsObject"/> interface.
/// </para><para>
/// Based on the technique described here: 
/// http://stackoverflow.com/questions/2509316/best-way-to-mock-wcf-client-proxy
/// </para>
/// </remarks>
<#	} #>
public class <#= clientFactory #> : <#= clientFactoryInterface #>
{
    public <#= clientInterface #> Build<#= serviceClient #>()
    {
        return new <#= clientProxy #>();
    }
}

<#	manager.EndBlock(); 

} // foreach name in serviceClientNames

// Finally, generate the files and add them to the project:
manager.Process(generateIndividualFiles); #>